# Shamiri Digital Hub - Cursor IDE Rules

## Mandatory Validation Rules

### Zod Schema Validation - ABSOLUTE REQUIREMENT

**ALWAYS use Zod for ALL payload validation. This is NON-NEGOTIABLE.**

#### Required Patterns:

1. **API Routes**: Must validate request bodies with Zod schemas
```typescript
// REQUIRED pattern for all API routes
import { z } from "zod";
import { stringValidation } from "#/lib/utils";

const Schema = z.object({
  // Define schema here
});

export async function POST(request: NextRequest) {
  const body = await request.json();
  const result = Schema.safeParse(body);
  
  if (!result.success) {
    const errorMessages = result.error.issues.map(
      (issue) => `${issue.path.join(".")}: ${issue.message}`
    );
    return NextResponse.json({ 
      error: "Validation failed", 
      details: errorMessages 
    }, { status: 400 });
  }
  
  const validatedData = result.data;
  // Use validatedData, never raw body
}
```

2. **Server Actions**: Must validate FormData with Zod
```typescript
"use server";
import { z } from "zod";

const Schema = z.object({
  // Define schema
});

export async function myAction(formData: FormData) {
  const result = Schema.safeParse({
    field: formData.get("field"),
  });
  
  if (!result.success) {
    return { success: false, errors: result.error.flatten().fieldErrors };
  }
  
  const validatedData = result.data;
}
```

3. **React Forms**: Must use zodResolver
```typescript
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";

const FormSchema = z.object({
  // Define schema
});

type FormData = z.infer<typeof FormSchema>;

const form = useForm<FormData>({
  resolver: zodResolver(FormSchema),
});
```

#### PROHIBITED Patterns:

- ❌ Direct use of `request.json()` without validation
- ❌ Custom validation functions for structured data  
- ❌ Manual type definitions that duplicate schema types
- ❌ `any` types from API requests
- ❌ Unvalidated form data in server actions

#### Schema Naming Convention:
- Use `[Entity][Action]Schema` format
- Examples: `UserCreateSchema`, `SessionAnalysisSchema`, `ProfileUpdateSchema`

#### Error Handling:
- Always use `safeParse()` instead of `parse()`
- Return structured error responses with field-specific messages
- Use `result.error.flatten().fieldErrors` for form validation

## Component and Styling Rules

### Component Reuse - MANDATORY
- **ALWAYS search existing components before creating new ones**
- Use `ast-grep` to find existing components:
```bash
ast-grep --pattern 'export default function $NAME($$$) { $$$ }' --lang typescript
```
- Reuse components from `/components/ui/` and `/components/common/`

### TailwindCSS Only - MANDATORY
- **NO custom CSS files** (except globals.css)
- **NO inline styles** with `style` prop
- Use design system colors only:
  - `shamiri-new-blue`, `shamiri-light-red`, `shamiri-green`
  - `blue-base`, `green-base`, `red-base` (semantic colors)
- Use `cn()` utility for conditional classes

## Code Quality Requirements

### Mandatory Quality Gates:
Before marking ANY task complete, MUST run:
1. `npm run typecheck` - Fix all TypeScript errors
2. `npm run lint` - Fix all ESLint errors  
3. `npm run stylecheck` - Ensure Prettier formatting

### TypeScript Rules:
- Use strict mode TypeScript
- Generate types from Zod schemas: `type MyType = z.infer<typeof MySchema>`
- No `any` types allowed
- Prefer interfaces for component props

### Import Patterns:
- Use `#/` alias for internal imports
- Import Zod as `import { z } from "zod"`
- Import validation utilities: `import { stringValidation } from "#/lib/utils"`

## Database and API Rules

### Prisma Patterns:
- Use selective `include` statements
- Always use `where` clauses for filtering
- Use transactions for complex operations
- Use `select` when only specific fields needed

### API Error Handling:
- Return structured error responses
- Use appropriate HTTP status codes
- Include detailed validation errors
- Handle JSON parsing errors

## Git and Commit Rules

### Commit Format - MANDATORY:
Use conventional commit syntax:
- `feat(scope): description` - New features
- `fix(scope): description` - Bug fixes  
- `chore(scope): description` - Maintenance
- `refactor(scope): description` - Code refactoring

### Examples:
- `feat(api): add session analysis endpoint with zod validation`
- `fix(validation): improve error messages for form fields`
- `chore(deps): update zod to latest version`

## Architecture Patterns

### File Organization:
- Schemas in `schema.ts` files alongside components
- Server actions in `actions.ts` files
- Reusable validators in `#/lib/validators.ts`

### Role-Based Access:
- Use existing RBAC patterns
- Check user roles before data access
- Filter data based on user permissions

### Next.js App Router:
- Use Server Components by default
- Use Server Actions for form handling
- Implement proper loading and error states

## Project-Specific Rules

### Session Management:
- Link to existing `InterventionSession` model
- Use proper relationship patterns
- Follow existing attendance tracking patterns

### Rating Systems:
- Use 1-7 scale for intervention ratings (established pattern)
- Validate rating ranges with Zod: `.min(1).max(7)`
- Use existing rating components where possible

### Data Tables:
- Reuse existing `DataTable` component
- Follow established column patterns
- Implement proper filtering and sorting

## Code Review Checklist

Before any code review or PR:
- [ ] All validation uses Zod schemas
- [ ] No direct `request.json()` usage
- [ ] All forms use `zodResolver`
- [ ] Types generated from schemas with `z.infer<>`
- [ ] Quality gates pass (typecheck, lint, stylecheck)
- [ ] Existing components reused where possible
- [ ] TailwindCSS only (no custom CSS)
- [ ] Proper error handling implemented
- [ ] Conventional commit format used
- [ ] Code is self-documenting with minimal comments
- [ ] Comments only explain WHY, not WHAT

## Code Documentation Rules

### Comment Policy - MANDATORY
**ABSOLUTE RULE: CODE SHOULD BE SELF-DOCUMENTING**

#### REQUIRED Comments:
- Complex business logic that isn't obvious
- Security-sensitive operations  
- Performance optimizations
- Framework workarounds
- Non-trivial algorithms

#### PROHIBITED Comments:
- ❌ Obvious code explanations
- ❌ Restating what code does
- ❌ TODO comments (use issues)
- ❌ Commented-out code (use git)
- ❌ Outdated information

#### Self-Documenting Code Patterns:

```typescript
// ❌ BAD: Obvious comments
// Create user in database
const user = await db.user.create({ data });

// ✅ GOOD: Self-explanatory
const user = await db.user.create({ data });

// ✅ GOOD: Complex business rule needs explanation
// Fellows can only access sessions in their assigned hub
// unless supervisor grants explicit override permission
const canAccess = fellow.hubId === session.hubId || supervisorOverride;
```

#### Use Descriptive Names:
```typescript
// ❌ BAD: Unclear
const data = process(input);

// ✅ GOOD: Self-explanatory
const validatedSessionAnalysis = validateAnalysisData(rawInput);
```

#### Extract Complex Logic:
```typescript
// ❌ BAD: Inline complexity
if (user.role === "FELLOW" && user.hubId === session.hubId && active) {
  // logic
}

// ✅ GOOD: Extracted function  
const canFellowAccessSession = (fellow, session) => 
  fellow.hubId === session.hubId && fellow.active;

if (user.role === "FELLOW" && canFellowAccessSession(user, session)) {
  // logic
}
```

## Anti-Patterns to Avoid

### Validation Anti-Patterns:
```typescript
// ❌ DON'T: Custom validation
function validateUser(data: any) {
  if (!data.name) return false;
  return true;
}

// ❌ DON'T: Direct JSON parsing
const data = await request.json();
// Use data directly without validation

// ❌ DON'T: Manual type definitions
interface User {
  name: string;
  email: string;
}
```

### Component Anti-Patterns:
```typescript
// ❌ DON'T: Custom CSS
<div style={{ color: 'red' }}>

// ❌ DON'T: Non-design-system colors  
<div className="bg-red-500">

// ❌ DON'T: Duplicate components
function MyButton() { /* custom button logic */ }
```

### Comment Anti-Patterns:
```typescript
// ❌ DON'T: Obvious comments
// Set the name variable to the user's name
const name = user.name;

// ❌ DON'T: Commented-out code
// const oldFunction = () => { ... }

// ❌ DON'T: TODO comments
// TODO: Fix this later

// ❌ DON'T: Redundant comments
// Return true if valid, false if invalid
return isValid;
```

Follow these rules strictly to maintain code quality and consistency across the Shamiri Digital Hub platform.